\documentclass[preprint]{iacrtrans}
\usepackage[utf8]{inputenc}

% Select what to do with todonotes: 
% \usepackage[disable]{todonotes} % notes not showed
\usepackage[draft,color=orange!20!white,linecolor=orange,textwidth=3cm,colorinlistoftodos]{todonotes}   % notes showed
\setlength{\marginparwidth}{3cm}
\usepackage{graphicx}
\usepackage{soul}
\graphicspath{{images/}} % end dirs with `/'
% \usepackage{longtable}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{backgrounds}
\usetikzlibrary{arrows}
\usetikzlibrary{crypto.symbols}
\tikzset{shadows=no}        % Option: add shadows to XOR, ADD, etc.

\author{Ella Rose}
\institute{Paso Robles, CA \email{python_pride@protonmail.com}}
\title[LWE Trapdoor One-Way Function]{LWE Trapdoor One-Way Function}

\begin{document}

\maketitle

% use optional argument because the \LaTeX command breaks the PDF keywords
\keywords[Homomorphic Encryption, Public Key Cryptography]{Homomorphic Encryption, Public Key Cryptography}

\begin{abstract}
 We define a simple trapdoor function based on the Learning-With-Errors problem in one dimension. The trapdoor algorithm is time and space efficient: We can perform tens of thousands of public and private key operations per second with a naive python implementation on modest hardware, and the keys and ciphertexts are small.
 \end{abstract}

\todototoc
\listoftodos

How does all this compares to others methods ?

\section{Introduction}
A Trapdoor One-Way Function (TOWF) is a function that is easy for anyone to compute in one direction, but is hard to compute in reverse without some additional piece of information. TOWFs are useful for cryptography, because they make constructing various public key primitives a relatively straightforward exercise.

The Learning-With-Errors (LWE) problem is a mathematical problem that is believed to be difficult to solve efficiently even with a quantum computer. A 1-dimensional LWE problem takes the form $a s + e \mod P$, where $a, P$ are known and $s, e$ are secret, random values.

In this paper we define a candidate TOWF based on 1-dimensional LWE. It is based on a simple observation of a congruence, $a^{-1}(a s + e) \equiv s + a^{-1} e \mod P$, along with some subtle manipulation of the sizes of the numbers involved. The trapdoor information is the short inverse $a^{-1}$, which allows the recovery of $s, e$ from a point $a s + e \mod P$, provided some constraints on the sizes of numbers are satisfied.

We discuss the possibilities to use the TWOF to construct basic public key algorthims for encapsulating keys, public key encryption, and creating digital signatures. We go on to provide statistics for a key encapsulation mechanism, gathered using our open source public domain implementation of the algorithm. We conclude with some open problems about formal security proof for the algorithm.

\subsection{Definitions}
We $+$ to denote addition, $a b$ to indicate multiplication, $a / b$ to denote division, and $\mod p$ to denote the modulo operation. We use $\leftarrow$ to indicate the assignment of a value to a name. We use the function $inverse(k, n)$ to indicate the computation of the modular multiplicative inverse of $k \mod n$. We use the function $random(k)$ to indicate the generation of of a random $k$-bit integer. We write application of the public key operation as $key_{pub}(s,\ e)$, and application of the private key operation as $key_{priv}(c)$.

\section{Algorithm}
There is a publicly agreed upon modulus $P$. All math is done in the field of integers modulo $P$. The same $P$ may always be used. It should be prime; It it is not secret, and otherwise only needs to be both agreed upon and large enough. The size of $P$ is determined by the rest of the parameter sizes which are discussed below; In our python implementation which targets a 256-bit security level, $P$ is about 783 bits in size. The larger $P$ is, the longer the BigNum arithmetic operations take, and the larger ciphertexts become; Consequently, we opt for the smallest $P$ possible.

\subsection{Design Outline}
Consider the following expression:

\begin{flalign*}
c \leftarrow a s + e \mod P
\end{flalign*}

We refer to this expression as the public key operation. If the expression $a s + e$ were over integers instead of modulo $P$, then we could recover $e$ simply by performing $c \mod a$; We could similarly recover $s$ by performing $c / a$. However, since $a s > P$ then this will no longer work. 

Given $c, a, P$, we can recover $s, e$ using the following algorithm:

\begin{flalign*}
t \leftarrow a^{-1} c\\
s \leftarrow t \mod a^{-1}\\
t \leftarrow t - s \\
e \leftarrow t / a^{-1}
\end{flalign*}

Where $a^{-1}$ is the output of $inverse(a, P)$.

The step $s \leftarrow t \mod a^{-1}$ will only function correctly if $s < a^{-1}$ and if $a^{-1} e < P$. We leverage this latter fact to create the trapdoor: We select a suitable $a^{-1}$ that is large enough such that $s < a^{-1}$ and small enough such that $a^{-1} e < P$. Then, we calculate the modular multilicative inverse $a \leftarrow inverse(a^{-1}, P)$. This number will likely be very large, closer to $P$ in size then to $a^{-1}$. To create a public key, we then encrypt $a$ using a random $r$ to preclude the ability of others to calculate $a^{-1}$. 

The public key provides the ability to compute the forward operation $a s + e \mod P$ because there is no size constraint on $a$ for this operation to function (as long as $a < P$ anyways). Supplying the inverse of the public key to the inversion algorithm will not produce correct plaintext, because the generated value will be too large. We can witness this via the attempt below:

\begin{flalign*}
k_{pub} \leftarrow a r\\
s \leftarrow random(s_{size})\\
e \leftarrow random(e_{size})\\
c \leftarrow k_{pub} s + e\\
k_{pub}^{-1} \leftarrow inverse(k_{pub}, P)\\
c_i \leftarrow k_{pub}^{-1} c\\
c_i \equiv s + a^{-1} r^{-1} e\\
\end{flalign*}

In the final line $c_i \equiv s + a^{-1} r^{-1} e$, we can see that the inverse of the public key will be too large if $a^{-1} r^{-1} e > P$; In such a case, $s + a^{-1} r^{-1} e \mod a^{-1} r^{-1}$ will not yield $s$; While $a^{-1}$ is relatively small, $r^{-1}$ is (most likely) large - Ultimately, the size of $a^{-1} r^{-1}$ is roughly the same as $a r$, and so this alternative perspective of $s + a^{-1} r^{-1} e$ offers no more advantage to recovering $s, e$ as then the original $ars + e$ did.

This is in contrast to the perspective that the holder of $a^{-1}$ has:

\begin{flalign*}
\dots\\
c_i \leftarrow c a^{-1}\\
c_i \equiv sr + a^{-1} e
\end{flalign*}

We can see the difference in the final line $c_i \equiv sr + a^{-1} e$ from before; While the $r$ variable is still present on the left term, $a^{-1} e < N$ and so $sr + a^{-1} e \mod a^{-1}$ will yield $sr$ and the inversion algorithm will work as intended. The presence of the $r$ variable on the left does require that $a^{-1}$ be larger to ensure that $sr < a^{-1}$.

\subsection{Key Generation}
\begin{flalign*}
k_{priv} \leftarrow random(priv_{size})\\
a \leftarrow inverse(k_{priv}, N)\\
r \leftarrow random(r_{size})\\
k_{pub} \leftarrow a r\\
\end{flalign*}

For the trapdoor to function correctly, $priv_{size}$ must be selected such that $e k_{priv} < P$, as well as $k_{priv} > r s$, where $s, e$ are the security parameters of the public key operation. For 256-bit $e, r, s$ values, $priv_{size}$ is 520 bits, while $P$ is 783 bits. The size of the modulus effectively determines the size of the public key; This results in a public key size of 783 bits, for the aforementioned parameters.

\subsection{Public Key Operation}
\begin{flalign*}
a \leftarrow k_{pub}\\
s \leftarrow random(s_{size})\\
e \leftarrow random(e_{size})\\
c \leftarrow a s + e\\
\end{flalign*}

\subsection{Private Key Operation}

\begin{flalign*}
t \leftarrow a^{-1} c\\
sr \leftarrow t \mod a^{-1}\\
t \leftarrow t - sr\\
s \leftarrow sr r^{-1}\\
e \leftarrow t a\\
output\ s,\ e
\end{flalign*}

The private key operation presented here is slightly more complex than the example demonstrated earlier because of the presence of the $r$ term. Either $s, e$ or a combination of both may be used in different contexts to achieve different effects.

\subsection{Homomorphism}
Ciphertexts support integer addition: Two ciphertexts of the form $a s + e$ may be added together to yield $a (s_1 + s_2) + e_1 + e_2$. 

Ciphertexts may be multiplied by plaintext scalars - this follows from the previous property, as $c + c \equiv 2c$.

Additionally, adjustments may be made to the value of $e$ via addition/subtraction with a plaintext scalar: $a s + e + r$.

It should be noted that multiplication will quickly increase the size of the terms in the expressions, and if the size of the terms grows too large, decryption will fail.

\section{Key Encapsulation, Public Key Encryption, and Digital Signatures}
\subsection{Key Encapsulation}
Given a TWOF, a basic algorithm to exchange keys can be constructed as follows: Assuming that Alice has Bob's public key already, she simply applies the public key operation to a random value and sends the output to Bob; Bob can then use the private key to recover the random value. Assuming that both parties are honest, then the random value will be unknown to all parties but Alice and Bob, and they can use this information to construct a secured communications channel.

The basic mechanism presented in this section is not sufficient for constructing a general purpose secure communications protocol - for example, authentication is not addressed. The construction of such protocols is outside of the scope of this paper. 

\subsection{Public Key Encryption}
We can generalize and say that the Key Encapsulation Mechanism presented in the prior section is an example of using the trapdoor for public key encryption on random plaintext values. It is clear then that one of the values of $s, e$ can be used to store a plaintext value.

Considering the efficiency of hybrid cryptosystems, where an asymmetric algorithm is used to establish a key for a message, then a symmetric cipher is used to perform the actual encryption, we first must determine what can be gained by storing a message inside the public key ciphertext.

The most attractive feature is probably the homomorphism - the ability to add and manipulate ciphertexts can enable more complex cryptographic schemes and protocols. However, the manner with which plaintext information is stored and possibly padded will influence the nature of the homomorphic properties, and a careful configuration will be required to preserve the desired relationship(s). For example, if $e$ is used to store the message, then plaintext adjustments may be made to the resultant ciphertext; However, if $s$ is used as to store the message, then the ciphertext will no longer facilitate plaintext adjustments.

\subsection{Digital Signatures}
A TWOF can serve as a fundamental part of a digital signature scheme: The private key operation can be used to produce a preimage for a given ciphertext, and the corresponding public key can be used to check if the preimage outputs the challenge ciphertext. 

We note that ciphertexts produced by the TWOF are additively homomorphic - this means that signatures will possess this quality as well. Usually this feature can be removed by incorporating a hash function into the signature process and padding the result before applying the private key signing operation. 

\section{Security Analysis}
There are two main goals: First, given the public key, the private key must not be obtainable; Second, The output of the public key operation must not be invertible without the private key.

There is a third goal that is only applicable in the context of digital signatures: The output of the private key operation must not leak the private key. This goal is not applicable in the context of key exchange, because the adversary does not see the output of the private key operation.

\subsection{Key Generation}
Obtaining the private key from the public key must be done by guessing one of $a, a^{-1}, r$. If this were not the case, then whatever algorithm that can be used to recover any of $a, a^{-1}, r$ from $a r \mod P$ could be used to recover plaintexts from ciphertexts of the form $m k \mod P$ for random $m, k$ where one of $m, k$ is smaller then the other (but still large enough to reduce modulo $P$). It seems unlikely that such an attack exists and is faster then guessing $a, a^{-1},  r$. 

This implies that there does not exist an algorithm to recover the private key from the public key, other then brute force guessing.

\subsection{Public Key Operation}
The public key operation appears to be a 1-dimensional version of the learning-with-errors problem.\\

We will first consider the case where $e \leftarrow random(1)$. The task of the adversary is to recover $e$, given $a,\ a s + e$ for $a \leftarrow \{0,\ \dots,\ P\}$, $s \leftarrow \{0,\ \dots,\ P\}$. If an adversary can guess the least significant bit of $a s$, then they can obtain $e$ from $a s + e$.

If we consider the case where $a = 1$, then $a s + e \equiv s + e \mod P$ for uniformly random values $s, e$. Recovering $s,\ e$ in this situation is clearly intractable.

If we consider 8-bit $a, s$ values and $P = 257$, then we can evaluate the function $a s$ on values $\{0,\dots,\ 256\}$ and produce an 8-bit s-box, like the kind used in symmetric cryptography. We can then analyze the result with the same techniques and tools. We have done so and found differentials ranging from probability $62/256$ in the worst case, to around $64/256$ in the average case, to $254/256$ in the worst case. However, considering that each ciphertext $a s + e$ uses a unique, random $s$, it is not clear how to select a differential to try to exploit. Additionally, real instances of the problem will use $a,\ s$ values that are much larger then any tool for analyzing s-boxes can handle.

\subsection{Private Key Operation}
Utilizing the TWOF here as a signature function does not provide the same confidence as using the TWOF for key exchange: With the private key operation, the expressions do not take the form of the LWE problem. Despite this, it is not obvious to us how to take advantage of this fact to recover the private key.

\subsection{Side Channel Analysis}
Assuming that BigNum operations can be implemented in a manner that does not leak timing information, it appears that a naive implementation of the algorithm is resistant to timing side channel analysis, as there are no tables or branches in the algorithm.

\section{Metrics}
We have implemented the trapdoor and developed a key encapsulation mechanism with it. Using our open-source public-domain python implementation that is configured for a 256-bit security level, we can perform 10,000 public key operations in 1 second. We can perform roughly 30,000 private key operations per second. Our tests were performed on modest hardware, namely an Intel Celeron N2830 2.16GHz with 2 cores. 

In our implementation, most of the time for the public key operation is spent generating $s$ and $e$. In a synthetic test where $s, e$ are not generated for each invocation of the function, we can perform 100,000 public key operations per second.

Key sizes and ciphertext sizes are relatively small - ciphertexts and public keys are effectively the same size as the modulus; In our implementation, ciphertexts and public keys are about 783 bits in size.

Private keys are also quite small, with certain time/space tradeoffs available: In the most compact scenario for key encapsulation, the private key can require only 520 bits for storage, used to store only the short inverse $a^{-1}$. In the worst case scenario, where each of $a,\ a^{-1},\ r$ is stored, the private key size requires slightly less then 1600 bits of storage space. 

Our implementation is optimized for clarity and readability. Much of the computation time is spent on bignum operations, and while an optimized C implementation may certainly be faster, it is not required to obtain an acceptable level of performance in the context of hybrid cryptosystems. 

\section{Open Problems}
Our results are lacking in formal rigorous proof; We do not posses the requisite skills to create such proofs. We leave it as an open problem to formally prove or dis-prove the security of the key generation function and public key operation.

We do not know if the private key operation can be proven secure; We leave this as an open problem, along with the construction of a concrete digital signature scheme.

\section{Conclusion}
We define a conceptually simple, resource-practical Trapdoor One-Way Function. We discuss the potential applications of such a function, and provide performance statistics from our open-source public-domain python implementation of a key encapsulation mechanism using the trapdoor function. Finally, we discuss some open problems related to formally proving the security of the algorithm.
\end{document}

