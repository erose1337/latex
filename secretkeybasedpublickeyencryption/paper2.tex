\documentclass[preprint]{iacrtrans}
\usepackage[utf8]{inputenc}

% Select what to do with todonotes: 
% \usepackage[disable]{todonotes} % notes not showed
\usepackage[draft,color=orange!20!white,linecolor=orange,textwidth=3cm,colorinlistoftodos]{todonotes}   % notes showed
\setlength{\marginparwidth}{3cm}
\usepackage{graphicx}
\usepackage{soul}
\graphicspath{{images/}} % end dirs with `/'
% \usepackage{longtable}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{backgrounds}
\usetikzlibrary{arrows}
\usetikzlibrary{crypto.symbols}
\tikzset{shadows=no}        % Option: add shadows to XOR, ADD, etc.

\author{Ella Rose}
\institute{Paso Robles, CA \email{python_pride@protonmail.com}}
\title[A Practical Public Key Encryption Algorithm]{A Practical Public Key Encryption Algorithm}

\begin{document}

\maketitle

% use optional argument because the \LaTeX command breaks the PDF keywords
\keywords[Homomorphic Encryption, Public Keyc Encryption]{Homomorphic Encryption, Public Key Encryption}

\begin{abstract}
 We define a public-key encryption construction that is efficient in terms of key size, ciphertext size, key generation time, and encryption/decryption time. The construction requires only addition, multiplication, and modular reduction on large integers.
 \end{abstract}

\todototoc
\listoftodos


\section{Introduction}
 Ciphers that support homomorphic operations on ciphertexts are very attractive because they tend to make the creation of public key encryption schemes relatively straightforward and simple. This paper presents such a public key encryption system, as well as a secret key cipher that is suitable for instantiating the system.

\section{Definitions}
We use $+$ to denote addition, $a * b$ to denote multiplication, $a / b$ to denote division, and $\mod p$ to denote the modulo operation. We use the function $inverse(k, n)$ to indicate the computation of the modular multiplicative inverse of $k \mod n$.

\section{General Properties of Homomorphic Ciphers}
\subsection{Basic Definition of Homomorphic Cipher}
A cipher is homomorphic if it supports:

\begin{align}
 D(E(m1) * (m2)) == m1 ** m2
\end{align}

where $x * y$ and $x ** y$ are some operation(s) such as addition or multiplication. The two operations do not necessarily have to be the same operation, but often times are.

A partially homomorphic cipher is usually defined as supporting an unlimited quantity of a single type of operation on ciphertexts, such as $D(E(m1) + E(m2)) == m1 + m2$.

We will note that such a property implies the ability to perform another operation with plaintext values as the second operand, as in $D(E(m1) * m2)$ == m1 * m2. Put in other words, suppose that addition can be performed on ciphertexts; Then the sum of a ciphertext with itself would be equivalent to multiplication of the ciphertext by 2. Thus the ability to add ciphertexts to each other necessarily implies the ability to multiply a ciphertext by a plaintext amount.

A fully homomorphic cipher supports multiple operations on ciphertexts, usually addition and multiplication. The public key encryption construction presented in this paper does not require a fully homomorphic cipher, only a partially homomorphic cipher. We mention the term here only for the sake of completeness.

\subsubsection{Access to Encryption Oracle}
Interestingly, with homomorphic ciphers, access to a single ciphertext can be effectively equivalent to access to an encryption oracle, in that the one ciphertext can be manipulated to create new ciphertexts, the plaintext values for which will have a known relation to the previous. So in this sense, homomorphic ciphers must be secure against a type of adaptive chosen plaintext attack even if only a single plaintext is released.

\section{Algorithm}
First, we will define the public key encryption construction. Then, we will define a secret key cipher that is suitable for instantiating the construction.

There is a publicly agreed upon modulus $n$. The same $n$ may always be used; It it is not secret, and only needs to be both agreed upon and large enough. This modulus is used by both the secret key cipher and the public key cipher.

\subsection{Public Key Construction}
\subsubsection{Basic Concept}
A public key consists of two ciphertexts, which are homomorphic encryptions of $1$ and $0$. The encryption function must support the addition of ciphertexts modulo $n$, which also implies that ciphertexts can be multiplied by plaintext values.

\subsubsection{Key Generation}
Generation of a public key is very simple: Distribute one encryption of $1$, as well an encryption of $0$. The size of the public key will be determined by the size of the ciphertexts generated by the secret key cipher. 

\begin{flalign*}
p_0 := encrypt(0, p_k) \\
p_1 := encrypt(1, p_k) \\
key_{public} = (p_0, p_1)
\end{flalign*}

\subsubsection{Encryption}
To encrypt a value: First the encryption of $1$ is multiplied by the plaintext message; Then, the encryption of $0$ is multiplied by a random plaintext integer; Finally, these products are summed modulo n to produce the ciphertext.

\begin{flalign*}
ciphertext := (p_0 * r) + (p_1 * m) \mod n
\end{flalign*}

\subsubsection{Decryption}
Decryption simply applies the decryption circuit of the secret key cipher to the plaintext. The result will be equivalent to the message, because:

\begin{flalign*}
D(ciphertext) \equiv (0 * r) + (1 * m)\equiv m
\end{flalign*}

\subsection{Secret Key Cipher}
\subsubsection{Basic Concept}
Points on (and off of) a lattice can be added together, and this effect is preserved even after being multiplied modulo a prime. We exploit this modular reduction to both provide security and decrease the size of ciphertexts considerably.

Multiple points can be superpositioned together via the addition operator, which provides a mechanism for randomizing the ciphertext. Given a point in the form of $(p * q_1) + (p ^ 2 * q_2)$, $p * q_1$ can be recovered by computing $(p * q_1) + (p ^ 2 * q_2) \mod p ^ 2$. This process can be repeated for successive powers of $p$. We utilize a three-tiered ciphertext using this technique, where the base point encodes the messages, and the squared/cubed points are both used for randomization.

\subsubsection{Key Generation}
\begin{flalign*}
p := random\_integer\\
k := random\_integer\\
k_i := inverse(k, n)
\end{flalign*}

\subsubsection{Key Generation}
$p$ must be selected such that it is greater then the largest message that will be encrypted. If 256-bit messages are to be encrypted, then $p$ must be greater then 256 bits in size. We elect to utilize 264 bits for our $p$ value. Similarly, if $k$ is to remain unguessable even in the face of an adversary with a quantum computer, then $k$ should be at least 256 bits in size. We choose $k$ as an offset from $n$, rather then as an offset from $0$ - this ensures that $k * q \mod n$ is always large enough to reduce, even if $q$ is small. This results in a larger value for $k$.\\

\subsubsection{Encryption}
\begin{flalign*}
t := (p * m) + (p ^ 2 * random\_integer) + (p ^ 3 * random\_integer)\\
c: = (k * t) \mod n
\end{flalign*}

\subsubsection{Decryption}
\begin{flalign*}
t := (k_i * c) \mod n\\
t := t \mod p ^ 3 \mod p ^ 2\\
m := t / p
\end{flalign*}


\section{Security Analysis}
\subsection{Secret Key Cipher}
The secret key cipher effectively consists of two separate sections; In the first section, a randomized ciphertext is created. The second section is a re-ordering of the ciphertext blocks via multiplication modulo n. This section exists to make the first section "harder" then it would be if it was not reduced modulo n. Note that $k$ is not sufficient to decrypt a given ciphertext. An adversary must acquire both $k$ and $p$, or find a way to recover $p$ without $k$. Given only $k$ and ciphertexts, it should still be difficult to recover a plaintext.\\

The security of $k * q \mod n$ as a cipher seems to reduce almost exclusively to the distribution of values for $q$, which is determined by $(p * m) + (p ^ 2 * r_0) + (p ^ 3 * r_1)$. If this was a uniformly random value, then the secret key cipher would be effectively equivalent to a One Time Pad, with a re-usable key. This is demonstrably not the case, as perfect secrecy is not provided by this cipher - A given ciphertext decrypts to one and only one particular plaintext message. We conclude that $(p * m) + (p ^ 2 * r_0) + (p ^ 3 * r_1)\mod n$  may not always follow a uniformly random distribution.\\

Encryptions of 0 take the form $x := k * ((p ^ 2 * r_0) + (p ^ 3 * r_1)) \mod n$. Given many such samples for random $r$, can $p$ or $k$ be recovered? Set $q := (p ^ 2 * r_0) + (p ^ 3 * r_1) \mod n$; If $q$ is unpredictable, then it should not be possible to recover $p$ or $k$ from encryptions of $0$.\\

Under chosen ciphertext attack, we can obtain the value of $(k_i \mod p ^ 3 \mod p ^ 2) / p$ by submitting the value of $1$ as a ciphertext to the decryption operation. Similarly, we can obtain the value of $(c * k_i \mod p ^ 3 \mod p ^ 2) / p$ for some chosen values $c$. It is not yet clear how this information can be leveraged to recover $p$ or $k_i$.\\

It is possible that somehow the relation between $p, p ^ 2, p ^3$ might be leveraged against the design. In such a situation, $p ^ 2$ and $p ^ 3$ can be changed to random numbers that are larger then $p ^ 2$ and $p ^ 3$, respectively. Currently, these points are generated as exponents of $p$ to save space, but this is not a requirement for the function of the construction.

\subsection{Public Key Cipher}
The security of the public key system seems very straightforward: as long as $p_0 * r \mod n$ produces an unpredictable random value, then $(p_1 * m) + (p_0 * r) \mod n$ is effectively equivalent to applying a random key to an encoding of the message. As long as the key material is unpredictable and remains unknown, then, given only a ciphertext and the public key, there shold be no way to recover the plaintext message.

If necessary, the construction can be generalized to use larger quantities of randomization points. This would increase the size of the public key.

\section{Metrics}
With the parameter sizes in this paper, a public key is 2800 bits in size, while a private key is about 4400 bits in size. Ciphertexts require 1400 bits of space to encrypt 256-bit plaintext values. \\

With our public domain python implementation, we can encrypt with the public key 10,000 256-bit messages in approximately 0.66 seconds, while we can decrypt 10,000 ciphertexts in approximately 0.93 seconds. While a python implementation may not be the fastest possible, it performs well as much of the computation time is spent on BigNum operations anyways.\\

The private key size could be decreased at the expense of computation time; The figure cited above represents the storage of $p, p ^ 2, p ^ 3, k, inverse(k, n)$. It is not necessary to store $p ^ 2$, $p ^ 3$, or $inverse(k, n)$. Storing only $p$ and $k$ yields private key sizes of about 1000 bits. Considering the relatively small amount of space required, compared to how long it takes to compute a square/cube/modular inverse, we choose to cache these values.

\subsection{Implementation Complexity}
The implementation complexity of the scheme is very low. The encryption and decryption functions for the public key construction can be implemented with a single line of code each in the function body. Our implementation of the algorithms spans approximately 100 lines, including the documentation and comments.\\

Additional code is required for supporting functions such as the generation of prime numbers (only if $n$ is being generated/not already established), computation of modular inverses, and unit testing. These are modest requirements that are already well facilitated by existing cryptographic libraries, and in other cases can be implemented without much complexity. \\

Assuming that BigNum operations can be implemented in a manner that does not leak timing information, it appears that a naive implementation of the algorithm is resistant to timing side channel analysis, as there are no tables or branches in the algorithm.

\section{Conclusion}
We define a conceptually simple, resource-practical public-key encryption algorithm. 
\end{document}

