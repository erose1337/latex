\documentclass[preprint]{iacrtrans}
\usepackage[utf8]{inputenc}

% Select what to do with todonotes: 
% \usepackage[disable]{todonotes} % notes not showed
\usepackage[draft,color=orange!20!white,linecolor=orange,textwidth=3cm,colorinlistoftodos]{todonotes}   % notes showed
\setlength{\marginparwidth}{3cm}
\usepackage{graphicx}
\usepackage{soul}
\graphicspath{{images/}} % end dirs with `/'
% \usepackage{longtable}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{backgrounds}
\usetikzlibrary{arrows}
\usetikzlibrary{crypto.symbols}
\tikzset{shadows=no}        % Option: add shadows to XOR, ADD, etc.

\author{}
\institute{}
\title[Lattice Trapdoor from Short Modular Inverse and Noisy Modulus]{Lattice Trapdoor from Short Modular Inverse and Noisy Modulus}

\begin{document}

\maketitle

% use optional argument because the \LaTeX command breaks the PDF keywords
\keywords[homomorphic encryption, public-key cryptography]{homomorphic encryption, public-key cryptography}

\begin{abstract}
\todo{}
 \end{abstract}

\section{Introduction}
\todo{}

\subsection{Definitions}
$a \leftarrow$ indicates the assignment of a value\\
$a \rightarrow b$ indicates that if $a$ is a true statement, $b$ is a consequence of it\\
$a + b$ indicates integer addition\\
$a b$ indicates integer multiplication\\
$a \mod b$ indicates modular reduction\\
$a / b$ indicates integer division\\
$random(size)$ indicates generation of a random $size$-bit integer\\
$inverse(a, b)$ indicates computation of the modular multiplicative inverse of $a$ modulo $b$\\

\section{Short Modular Inverses and Noisy Moduli}
$a^{-1} (a s + e) = s + a^{-1} e \mod q\\ \\$
$log(a^{-1}) + log(e) < log(q) \rightarrow s + a^{-1} e \mod q = s + a^{-1} e\\ \\$
$log(s) < log(a^{-1}) \rightarrow s = s + a^{-1} e \mod a^{-1}\\ \\$
A point $a s + e \mod q$  can be changed to a point $s + a^{-1} e \mod q$ via multiplication with the modular multiplicative inverse of $a$, $a^{-1}$. If $a^{-1}$ is smaller then $a$, then the total size of the value will shrink, assuming appropriate sizes for the values involved. With the right parameter choices, a point $a s + e \mod q$ can be changed to the point $s + a^{-1} e$. The former is over finite fields, while the latter is over integers. It is trivial to solve for $s$ when the problem is over integers.

The value $a^{-1}$ can serve as trapdoor information, but it can be trivially recovered from $a$ and $q$. The challenge then, is how to distribute $a, q$ such that nobody can recover the short modular inverse $a^{-1}$ from the pair? 

After having tried many combinations of techniques, the most promising answer appears to be the use of a noisy modulus. Instead of distributing $(a, q)$, $(a, q + r)$ may be distributed. The addition of the noise $r$ in the modulus prevents the computation of the short inverse $a^{-1}$; Anyone may calculate the inverse of $a \mod q + r$, but this value will most likely be approximately the size of the modulus and not be usable to shrink the value. 

It is possible to operate on an element of a field $q$ as if it were an element of $q_r$ and obtain approximately correct results. Some noise will be present as a result, and the value of the noise can be precisely determined by $r (x / q)$, where $x$ is the value that was reduced modulo $q + r$. The size of the noise scales quickly as the difference in size between $x$ and $q$ becomes large. As long as the noise $r (x / q)$ is no larger then the error $e$, it will not impede the ability to recover $s$.

\section{Public Key Cryptosystem}
A private key consists of a relatively small value $a^{-1}$ and a secret modulus $q$. A public key consists of the modular inverse of $a^{-1}$ modulo $q$ and a noisy version of the modulus $q_r$.  

The public key operation consists of selecting a random point $s$ on the $a$ lattice, adding some large error term $e$, then applying modular reduction by the modulus $q_r$.

The private key operation consists of multiplication by the short inverse $a^{-1}$ modulo $q$, followed by modulo $a^{-1}$. The multiplication by the short inverse changes the value to the point $e$ on the $a^{-1}$ lattice, with an error of $s$. This shrinks the size of the value to where it is effectively over integers, which allows the recovery of $s$ via simple modular reduction by $a^{-1}$.

\subsection{Key Generation}
\begin{flalign*}
a^{-1} \leftarrow random(a^{-1}_{size})\\
q \leftarrow random(q_{size})\\
a \leftarrow inverse(a^{-1}, q)\\
q_r \leftarrow q + random(r_{size})\\
key_{private} \leftarrow a^{-1},\ q\\
key_{public} \leftarrow a, q_r
\end{flalign*}

\subsection{Public Key Operation}
\begin{flalign*}
s \leftarrow random(s_{size})\\
e \leftarrow random(e_{size})\\
c \leftarrow a s + e \mod q_r
\end{flalign*}

\subsection{Private Key Operation}
\begin{flalign*}
s \leftarrow a^{-1} c \mod q \mod a^{-1}
\end{flalign*}

\subsection{Homomorphism}
Ciphertexts may be added together, and the result upon decryption will be equal to the sum of the plaintexts.
\begin{flalign*}
c_1 \leftarrow a s_1 + e_1 \mod q_r\\
c_2 \leftarrow a s_2 + e_2 \mod q_r\\
c_3 \leftarrow c_1 + c_2\\
s_3 \leftarrow a^{-1} c_3 \mod q \mod a^{-1}\\
s_3 \equiv s_1 + s_2
\end{flalign*}

\subsection{Parameter Sizes}
The sizes of the parameters need to be selected carefully to ensure that:\\
- the mechanism functions correctly (i.e. negligible probability of decryption failure)\\
- the mechanism is secure\\

The first requirement is relatively simple to fulfill, and all the parameter sizes can be described by a few simple expressions. It is necessary to include some padding bits to ensure a negligible probability of failure for the private key operation.\\

The requirements for correctness are:\\
$log(a^{-1}) > log(s)\\$
$log(e) <  log(q) - log(a^{-1})\\$
$log(r) < log(e) - log(s)$

The second requirement can be trivially fulfilled by selecting $log(e) >= log(q)$, as then the cipher is just a one time pad. Clearly, the construction here cannot be instantiated with such parameters while still fulfilling the first requirement of correctness, as we specifically require $log(e) < log(q)$. 

However, the algorithm can be instantiated with very large error terms relative to the size of the modulus. The limiting factor of the size of $e$ is how large $s$ is. As a secret value, it needs to be large enough to preclude an adversaries ability to guess it. This implies that for most uses, $s$ will be a maximum of 256 bits in size. The size of $q$ and $e$ can then be set such that the $s$ term becomes neglible in size and $e$ becomes approximately the same size as $q$.

The following algorithm may be used to calculate parameter sizes that fulfill the requirements of correctness. The size of $s$, the error coverage (the size of $e$ relative to the size of $q$), and the amount of padding are parameterized and configurable. The values indicate the size for the appropriate parameter in  bytes, except for the error coverage, which is expressed as a percent.

\todo{make it look nicer}
\begin{flalign*}
    base_{size} \leftarrow s_{size}\\
    e_{size} \leftarrow base_{size} - 1\\
    while\ (e_{size} - padding) / base_{size} < error_{coverage}:\\
        base_{size} \leftarrow 2 base_{size}\\
        e_{size} \leftarrow base_{size} - 1\\
    base_{size} \leftarrow base_{size} s_{size}\\
    e_{size} \leftarrow (e_{size} s_{size}) - 1 - padding\\   
    a^{-1}_{size} \leftarrow s_{size} + padding\\
    q_{size} \leftarrow base_{size}\\   
    r_{size} \leftarrow e_{size} - s_{size} - padding  \\
    output\ a^{-1}_{size},\ key_{size},\ error_{size},\ q_{size},\ r_{size}
\end{flalign*}    

For a 32-byte (256-bit) $s$ value, large error coverage $e_{size} / q_{size} >= .99$ and a 4-byte adjustment for padding, we have the following parameter sizes:

\begin{flalign*}
a^{-1}_{size} \leftarrow 36\\
s_{size} \leftarrow 32\\
e_{size} \leftarrow 16347\\
q_{size} \leftarrow 16384\\
r_{size} \leftarrow 16311
\end{flalign*}

For a 128-bit $s$ value and the same error coverage $e_{size} / q_{size} >= .99$ and 4-byte adjustment for padding, we have the following parameter sizes:

\begin{flalign*}
a^{-1}_{size} \leftarrow 20\\
s_{size} \leftarrow 16\\
e_{size} \leftarrow 8171\\
q_{size} \leftarrow 8192\\
r_{size} \leftarrow 8151
\end{flalign*}

\subsection{Compression}
The modulus $q$ and the noise $r$ can be selected such that the lower bits of $q_r$ are all zero. This can shrink the size of the modulus by $r_{size}$ bytes, as the zeros can be easily compressed. The compression/decompression algorithms are simply right shifting and left shifting, respectively. This effectively shrinks the size of the public key by almost half.

\subsection{Security Analysis}
\todo{}

\subsection{Metrics}
\todo{}

\section{Fully Homomorphic Encryption Over Finite Fields}
It is possible to instatiate the scheme from Fully Homomorphic Encryption Over The Integers over finite fields instead. This could shrink the space requirements by a considerable amount.

\todo{How much}

\section{Open Problems}
\todo{}

\section{Conclusion}
\todo{}

\section*{Acknowledgements}

\end{document}