\documentclass[preprint]{iacrtrans}
\usepackage[utf8]{inputenc}

% Select what to do with todonotes: 
% \usepackage[disable]{todonotes} % notes not showed
\usepackage[draft,color=orange!20!white,linecolor=orange,textwidth=3cm,colorinlistoftodos]{todonotes}   % notes showed
\setlength{\marginparwidth}{3cm}
\usepackage{graphicx}
\usepackage{soul}
\graphicspath{{images/}} % end dirs with `/'
% \usepackage{longtable}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\usetikzlibrary{backgrounds}
\usetikzlibrary{arrows}
\usetikzlibrary{crypto.symbols}
\tikzset{shadows=no}        % Option: add shadows to XOR, ADD, etc.

\author{Ella Rose}
\institute{Paso Robles, CA \email{python_pride@protonmail.com}}
\title[Lattice Trapdoor from Short Modular Inverse and Noisy Modulus]{Lattice Trapdoor from Short Modular Inverse and Noisy Modulus}

\begin{document}

\maketitle

% use optional argument because the \LaTeX command breaks the PDF keywords
\keywords[homomorphic encryption, public-key cryptography]{homomorphic encryption, public-key cryptography}

\begin{abstract}

 \end{abstract}

\section{Introduction}

\subsection{Definitions}
$a \leftarrow$ indicates the assignment of a value\\
$a \rightarrow b$ indicates that if $a$ is a true statement, $b$ is a consequence of it\\
$a + b$ indicates integer addition\\
$a b$ indicates integer multiplication\\
$a \mod b$ indicates modular reduction\\
$a / b$ indicates integer division\\
$random(size)$ indicates generation of a random $size$-bit integer\\
$inverse(a, b)$ indicates computation of the modular multiplicative inverse of $a$ modulo $b$\\

\section{Short Modular Inverses and Noisy Moduli}
$a^{-1} (a s + e) = s + a^{-1} e \mod q\\ \\$
$log(a^{-1}) + log(e) < log(q) \rightarrow s + a^{-1} e \mod q \equiv s + a^{-1} e\\ \\$
$log(s) < log(a^{-1}) \rightarrow s = s + a^{-1} e \mod a^{-1}\\ \\$
A point $a s + e \mod q$  can be changed to a point $s + a^{-1} e \mod q$ via multiplication with $a^{-1}$. If $a^{-1}$ is smaller then $a$, then the total size of the value will shrink, assuming appropriate sizes for the values involved. With the right parameter choices, a point $a s + e \mod q$ can be changed to the point $s + a^{-1} e$. The former is over finite fields, while the latter is over integers. It is trivial to solve for $s$ when the problem is over integers.

The value $a^{-1}$ can serve as trapdoor information, but it can be trivially recovered from $a$ and $q$. The challenge then, is how to distribute $a, q$ such that nobody can recover the short modular inverse $a^{-1}$ from the pair? 

After having tried many combinations of techniques, the most promising answer appears to be the use of a noisy modulus. Instead of distributing $(a, q)$, $(a, q + r)$ may be distributed. The addition of the noise $r$ in the modulus prevents the computation of the short inverse $a^{-1}$; Anyone may calculate the inverse of $a \mod q + r$, but this value will most likely be approximately the size of the modulus and not be usable to shrink the value. 

It is possible to operate on an element of a field $q$ as if it were an element of $q_r$ and obtain approximately correct results. Some noise will be present, and the value of the noise can be precisely determined by $r (x / q)$, where $x$ is the value that was reduced modulo $q + r$. The size of the noise scales quickly as the difference in size between $x$ and $q$ becomes large. As long as the noise is small enough, it will not impede the ability to recover $s$.

\section{Public Key Cryptosystem}
A private key consists of a relatively small value $a^{-1}$ and a secret modulus $q$. A public key consists of the modular inverse of $a^{-1}$ modulo $q$ and a noisy version of the modulus $q_r$.  

The public key operation consists of selecting a random point $s$ on the $a$ lattice, adding some large error term $e$, then applying modular reduction by the modulus $q_r$.

The private key operation consists of multiplication by the short inverse $a^{-1}$ modulo $q$, followed by modulo $a^{-1}$. The multiplication by the short inverse changes the value to the point $e$ on the $a^{-1}$ lattice, with an error of $s$. This shrinks the size of the value to where it is effectively over integers, which allows the recovery of $s$ via simple modular reduction by $a^{-1}$.

\subsection{Key Generation}
\begin{flalign*}
a^{-1} \leftarrow random(a^{-1}_{size})\\
q \leftarrow random(q_{size})\\
a \leftarrow inverse(a^{-1}, q)\\
q_r \leftarrow q + random(r_{size})\\
key_{private} \leftarrow a^{-1},\ q\\
key_{public} \leftarrow a, q_r
\end{flalign*}

\subsection{Public Key Operation}
\begin{flalign*}
s \leftarrow random(s_{size})\\
e \leftarrow random(e_{size})\\
c \leftarrow a s + e \mod q_r
\end{flalign*}

\subsection{Private Key Operation}
\begin{flalign*}
s \leftarrow a^{-1} c \mod q \mod a^{-1}
\end{flalign*}

\subsection{Homomorphism}
Ciphertexts may be added together, and the result upon decryption will be equal to the sum of the plaintexts.
\begin{flalign*}
c_1 \leftarrow a s_1 + e_1 \mod q_r\\
c_2 \leftarrow a s_2 + e_2 \mod q_r\\
c_3 \leftarrow c_1 + c_2\\
s_3 \leftarrow a^{-1} c_3 \mod q \mod a^{-1}\\
s_3 \equiv s_1 + s_2
\end{flalign*}

\subsection{Parameter Sizes}
The sizes of the parameters need to be selected carefully to ensure that:\\
- the mechanism functions correctly (i.e. negligible probability of decryption failure)\\
- the mechanism is secure\\

The first requirement is relatively simple to fulfill, and all the parameter sizes can be described by a few simple expressions. 
The requirements for correctness are:\\
$log(a^{-1}) > log(s)\\$
$log(e) <  log(q) - log(a^{-1})\\$
$log(r) < log(e) - log(s)$

The second requirement requires a quantatative evaluation that takes into account how the difficulty of the problem scales as the size of the error is increased relative to the size of the modulus. It is easy to see that if $log(e) >= log(q)$, then the cipher is effectively a one time pad, as there is at least one bit of random information per message bit. The construction here cannot be instantiated with such parameters while still fulfilling the first requirement of correctness, as we specifically require $log(e) < log(q)$. 

However, it can be instantiated with very large error terms relative to the size of the modulus. The limiting factor of the size of $e$ is how large $s$ is. As a secret value, it needs to be large enough to preclude an adversaries ability to guess it. This implies that for most uses, $s$ will be a maximum of 256 bits in size. The size of $q$ and $e$ can then be set such that the $s$ term becomes neglible in size and $e$ becomes approximately the same size as $q$.

\subsection{Security Analysis}

\subsection{Metrics}

\section{Fully Homomorphic Encryption Over Finite Fields}
It is possible to instatiate the scheme from Fully Homomorphic Encryption Over The Integers over finite fields instead. This could shrink the space requirements by a considerable amount.

\section{Open Problems}

\section{Conclusion}


\section*{Acknowledgements}

\end{document}